@startuml
' ============================================================
' Elegant UML for LArTPC Imaging Pipeline
' (classes, packages, relationships + call flow on new page)
' ============================================================

' -------- visual style (tasteful, neutral) ------------------
skinparam linetype ortho
skinparam dpi 120
skinparam Shadowing true
skinparam RoundCorner 8
skinparam ArrowColor #555555
skinparam Class {
  BackgroundColor #F7F9FC
  BorderColor #8899AA
  FontColor #1F2A44
}
skinparam Package {
  BackgroundColor #F3F6FB
  BorderColor #8BA5C1
}
skinparam Note {
  BackgroundColor #FFFDF7
  BorderColor #C4B07B
}
skinparam stereotypeCBackgroundColor #E8EEF7
skinparam stereotypeCBorderColor #8BA5C1
skinparam classAttributeIconSize 0

title LArTPC Imaging & Analysis – Architecture Overview

' -------- packages ------------------------------------------
package "Imaging" as PKG_IMAGING {
  class "image::ImageProperties" as ImageProps {
    .. core geometry ..
    - center_x_ : double
    - center_y_ : double
    - origin_x_ : double
    - origin_y_ : double
    - height_   : size_t
    - width_    : size_t
    - pixel_w_  : double
    - pixel_h_  : double
    - view_     : geo::View_t
    --
    + index(row, col) : size_t
    + col(x) : size_t
    + row(y) : size_t
    + height() : size_t
    + width()  : size_t
    + pixel_w() / pixel_h() : double
    + view() : geo::View_t
    + origin_x()/origin_y() : double
    + max_x()/max_y() : double
  }

  class "image::Image<T>" as ImageT <<template>> {
    - prop_   : ImageProperties
    - pixels_ : std::vector<T>
    --
    + set(row, col, value : T, accumulate=true) : void
    + get(row, col) : T
    + clear(value=T()) : void
    + data() : std::vector<T>
    + view()/height()/width() : ...
  }

  ' concrete node for dependencies that use Image<float>
  class "image::Image<float>" as ImageFloat <<template>>

  class "image::SemanticPixelClassifier" as SPC {
    + getSemanticLabel(pdg:int) : SemanticLabel
    + classifyParticles(event) : std::vector<SemanticLabel>
    --
    - assignLabelToProgenyRecursively(...)
  }

  enum "SemanticLabel" as SemanticLabel {
    Empty
    Cosmic
    Muon
    Electron
    Photon
    ChargedPion
    NeutralPion
    Neutron
    Proton
    ChargedKaon
    NeutralKaon
    Lambda
    ChargedSigma
    NeutralSigma
    Other
    Ambiguous
  }

  class "image::ImageProducer" as ImgProducerHelper <<static-utility>> {
    + constructPixelImages(event, hits, properties, detector_images, semantic_images, ...) : void
    --
    - labelSemanticPixels(...) : SemanticLabel
    - fillDetectorImage(...) : void
  }

  class "image::ImageAlgo" as ImageAlgo {
    - fWIREproducer : art::InputTag
    - fHITproducer  : art::InputTag
    - fMCPproducer  : art::InputTag
    - fBKTproducer  : art::InputTag
    - fADCImageThreshold : float
    - fGeo  : const geo::GeometryCore*
    - fDetp : const detinfo::DetectorProperties*
    --
    + produceImages(event, hits, properties, is_data, semantic_classifier, badChannels, detector_images, semantic_images) : void
  }

  class "image::InferenceEngine" as InferenceEngine {
    + runInference(detector_images, scratch, work, arch, weights, wrapper, assets) : float
    + runInferenceDetailed(detector_images, scratch, work, arch, weights, wrapper, assets, want_cls, want_seg) : Result
  }
  class "InferenceEngine::Perf" as IEPerf
  class "InferenceEngine::Result" as IEResult {
    + cls : std::vector<float>
    + segW, segH : uint32_t
    + seg_u/seg_v/seg_w : std::vector<uint8_t>
    + conf_u/conf_v/conf_w : std::vector<float>
    + features : std::vector<float>
    + feature_seed : uint32_t
    + perf : Perf
  }
}

package "DataProducts" as PKG_DATA {
  class "image::PlaneImage" as PlaneImage {
    + view  : int              ' geo::View_t
    + width : uint32_t
    + height: uint32_t
    + origin_x/origin_y : float
    + pixel_w/pixel_h   : float
    + adc : std::vector<float>
    + semantic : std::vector<int32_t>
  }

  class "image::InferenceScores" as InferenceScores {
    + names  : std::vector<std::string>
    + scores : std::vector<float>
  }
}

package "Modules / Tools (art)" as PKG_ART {
  class "ImageProducer (art::EDProducer)" as ImageProducerModule <<EDProducer>> {
    - fPFPproducer/fSLCproducer/fHITproducer/...
    - fIsData : bool
    - fImgW, fImgH : int
    - fADCThresh : float
    - fCentroidRadiusCm : float
    - fBadChannels : std::set<unsigned int>
    - fGeo  : const geo::GeometryCore*
    - fDetp : const detinfo::DetectorProperties*
    - fDriftStepCm, fPitchU, fPitchV, fPitchW : double
    - fSemantic : std::unique_ptr<SemanticPixelClassifier>
    - fAlgo     : std::unique_ptr<ImageAlgo>
    --
    + produce(event) : void
    .. helpers ..
    - loadBadChannels(filename)
    - collectAllHits(event, hitTag)
    - collectNeutrinoSliceHits(event) const
  }

  class "analysis::ImageAnalysis" as ImageAnalysis <<Tool>> {
    + configure(pset)
    + analyseSlice(event, pfp_proxies, is_data, is_selected)
    + setBranches(TTree*)
    + resetTTree(TTree*)
    --
    - countLabels(labels, n) : std::vector<int>
  }
}

package "Geometry / Detector" as PKG_GEO {
  enum "geo::View_t" as ViewT {
    kU
    kV
    kW
    kUnknown
  }
  interface "geo::GeometryCore" as GeoCore <<external>>
  interface "detinfo::DetectorProperties" as DetProp <<external>>
}

package "Reco & Sim (external)" as PKG_RECO {
  interface "art::Event" as ArtEvent <<external>>
  interface "recob::Wire" as RecobWire <<external>>
  interface "recob::Hit"  as RecobHit  <<external>>
  interface "simb::MCParticle" as MCP <<external>>
}

' -------- relationships (class diagram) ---------------------
ImageT *-- ImageProps : <<composition>>
ImageProps --> ViewT : uses
PlaneImage --> ViewT : view

SPC -down-> SemanticLabel : defines
ImageAlgo ..> ImgProducerHelper : <<calls static>>
ImageAlgo ..> SPC : <<uses>>
ImageAlgo ..> GeoCore : <<uses>>
ImageAlgo ..> DetProp : <<uses>>
ImgProducerHelper ..> RecobWire : <<reads>>
ImgProducerHelper ..> RecobHit  : <<reads>>
ImgProducerHelper ..> MCP       : <<assocs>>
ImgProducerHelper ..> SPC       : <<labels>>
ImgProducerHelper ..> GeoCore   : <<geometry>>
ImgProducerHelper ..> DetProp   : tick->x

InferenceEngine ..> ImageFloat : inputs
InferenceEngine *-- IEResult
InferenceEngine *-- IEPerf

ImageProducerModule o--> ImageAlgo : <<owns>>
ImageProducerModule o--> SPC : <<owns>>
ImageProducerModule ..> PlaneImage : produces slice/event
ImageProducerModule ..> ArtEvent   : framework IO

ImageAnalysis ..> PlaneImage : consumes slice/event
ImageAnalysis ..> ArtEvent    : framework IO

' -------- layout helpers & notes ----------------------------
note right of ImageProps
  Defines pixel grid in (X,Z) or (X,wire)
  for a single TPC view. Provides row/col
  mapping and bounds checks.
end note

note right of ImageAlgo
  Thin façade that prepares inputs and
  forwards work to image::ImageProducer.
end note

note bottom of ImgProducerHelper
  Static utility that:
  - scans wires and their ROI
  - thresholds ADC to detector image
  - assigns semantic labels (MC truth)
end note

legend right
  == Legend ==
  *--  composition (lifecycle ownership)
  o--  aggregation (unique_ptr members)
  ..>  usage / dependency
  <<EDProducer>>  art framework module
  <<Tool>>        art analysis tool
  <<external>>    external framework types
endlegend


' ============================================================
' =====================  SEQUENCE PAGE  ======================
' ============================================================
newpage
title LArTPC Imaging – Produce Path (Sequence)

actor "art::EventLoop" as Loop
participant "ImageProducer\n(art::EDProducer)" as Mod
participant "art::Event" as Ev
participant "ImageAlgo" as Algo
participant "image::ImageProducer\n(helper)" as Helper
participant "SemanticPixelClassifier" as Cls
participant "geo::GeometryCore" as Geo
participant "detinfo::DetectorProperties" as Detp

Loop -> Mod : produce(Ev)

Mod -> Ev : collectAllHits(fHITproducer)
Mod -> Mod : compute vtx & centroids\nbuild ImageProperties[U,V,W]
Mod -> Algo : produceImages(Ev, neutrinoHits, props,\n is_data, Cls, badChannels,\n det_slice, sem_slice)
Mod -> Algo : produceImages(Ev, allHits, props,\n is_data, Cls, badChannels,\n det_event, sem_event)

activate Algo
Algo -> Helper : constructPixelImages(Ev, hits, props,\n detImgs, semImgs, is_data,\n fWIREproducer, fHITproducer,\n fMCPproducer, fBKTproducer,\n Geo, Detp, thresh, Cls, badCh)
activate Helper

Helper -> Ev : getValidHandle<recob::Wire/Hit/MCP>()
Helper -> Cls : (if MC) classifyParticles(Ev)
loop for each wire
  Helper -> Geo : ChannelToWire / View / WirePtr
  Helper -> Detp : ConvertTicksToX(tick, plane)
  Helper -> Helper : fillDetectorImage(...)\nlabelSemanticPixels(...)
end
Helper --> Algo : detImgs[3], semImgs[3]
deactivate Helper

Algo --> Mod : slice & event images (U,V,W)
deactivate Algo

Mod -> Ev : put(std::vector<PlaneImage>, "slice")
Mod -> Ev : put(std::vector<PlaneImage>, "event")
Loop <-- Mod : done

@enduml
