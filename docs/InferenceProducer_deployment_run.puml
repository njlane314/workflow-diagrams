@startuml
' =============================================================================
' Inference deployment/run (InferenceProducer + InferenceProduction)
' Separate diagram focused only on how inference is executed
' =============================================================================
!pragma layout smetana

top to bottom direction
scale max 1320*1870

skinparam defaultFontSize 10
skinparam nodesep 14
skinparam ranksep 14
skinparam padding 2

!$INK     = "#111827"
!$MUTED   = "#6B7280"
!$ART     = "#1D4ED8"
!$TOOLS   = "#15803D"
!$CFG     = "#B45309"
!$DATA    = "#111827"
!$NOTE_BG = "#F9FAFB"
!$NOTE_BR = "#9CA3AF"

hide stereotype
skinparam backgroundColor #FFFFFF
skinparam defaultFontName Helvetica
skinparam defaultFontColor $INK
skinparam linetype ortho
skinparam shadowing false
skinparam roundCorner 0
skinparam dpi 160
skinparam defaultTextAlignment center
skinparam LineThickness 1
skinparam ArrowThickness 1.1
skinparam ArrowColor $INK
skinparam packageStyle rectangle
skinparam componentStyle rectangle

skinparam package<<cfg>> {
  BackgroundColor #FEF3C7
  BorderColor $CFG
  FontColor $INK
}
skinparam component<<cfg>> {
  BackgroundColor #FEF3C7
  BorderColor $CFG
  FontColor $INK
}
skinparam artifact<<cfg>> {
  BackgroundColor #FEF3C7
  BorderColor $CFG
  FontColor $INK
}

skinparam package<<art>> {
  BackgroundColor #E3EAFD
  BorderColor $ART
  FontColor $INK
}
skinparam component<<art>> {
  BackgroundColor #E3EAFD
  BorderColor $ART
  FontColor $INK
}

skinparam package<<tools>> {
  BackgroundColor #E0F2E9
  BorderColor $TOOLS
  FontColor $INK
}
skinparam component<<tools>> {
  BackgroundColor #E0F2E9
  BorderColor $TOOLS
  FontColor $INK
}

skinparam artifact<<data>> {
  BackgroundColor #F3F4F6
  BorderColor $DATA
  FontColor $INK
}

skinparam note {
  BackgroundColor $NOTE_BG
  BorderColor $NOTE_BR
  FontColor $INK
}

' =============================================================================
' Configuration
' =============================================================================
package "Configuration" <<cfg>> as CFG {
  component "Job launcher\nlar -c <job>.fcl" as USER <<cfg>>
  artifact "FHiCL pset\nInferenceProducer" as FCL <<cfg>>
  artifact "Models[]\nLabel/Arch\nWeights/Wrapper\nAssets" as MODELS <<cfg>>
  artifact "ScratchDir\n(+ assets base)" as PATHS <<cfg>>

  USER -down-> FCL : selects\nworkflow
  USER  -[hidden]right-> MODELS
  FCL   -[hidden]right-> PATHS
  MODELS -[hidden]down-> PATHS
}

' =============================================================================
' Inputs/outputs (event products)
' =============================================================================
package "Event products (input)" as EPIN {
  artifact "ImageProducts \"NuSlice\"\nU/V/W ADC planes" as IMAGES <<data>>
}

package "Event products (output)" as EPOUT {
  artifact "InferencePredProduct\nper-model scores" as PRED <<data>>
  artifact "InferencePerfProduct\nper-model timing/RSS" as PERF <<data>>
  PRED -[hidden]right-> PERF
}

' =============================================================================
' Inference in art + helper
' =============================================================================
package "Inference stage" <<art>> as STAGE {
  component "InferenceProducer\n(EDProducer)" as INFER <<art>>
  component "InferenceProduction\nrunInference(...)" as RUN <<tools>>
  INFER -down-> RUN : runInference\n(per model)
  RUN -up..> INFER : Result{scores, perf}
}

' =============================================================================
' External runtime + scratch artifacts
' =============================================================================
package "Scratch (request)" as SCRREQ {
  artifact "planes.bin\n(CHW float32)\nU,V,W" as REQBIN <<data>>
}

package "External inference runtime" <<tools>> as RT {
  artifact "inference_wrapper.sh\n(bash)" as WRAP <<cfg>>
  artifact "assets dir\n(code/config)" as ASSETS <<cfg>>
  artifact "weights file\n(model)" as WTS <<cfg>>
  artifact "/cvmfs\n(bind if needed)" as CVMFS <<cfg>>
  component "Apptainer\ncontainer" as APPT <<tools>>

  WRAP   -[hidden]right-> ASSETS
  WRAP   -[hidden]down->  WTS
  ASSETS -[hidden]down->  CVMFS
  WTS    -[hidden]right-> CVMFS

  WTS   -[hidden]down-> APPT
  CVMFS -[hidden]down-> APPT
}

package "Scratch (results)" as SCRRES {
  artifact "results.bin\n(IAOK header\n+ scores)" as RESBIN <<data>>
  artifact "metrics.meta\nkey=value lines" as META <<data>>
  artifact "stdout / stderr\n(log capture)" as LOGS <<data>>
  RESBIN -[hidden]right-> META
  RESBIN -[hidden]down->  LOGS
  META   -[hidden]down->  LOGS
}

' =============================================================================
' Layout: use two columns so the diagram isn't a tall skinny strip
' =============================================================================
CFG -[hidden]right-> EPIN
CFG -[hidden]down-> STAGE
EPIN -[hidden]down-> STAGE

STAGE  -[hidden]down-> SCRREQ
SCRREQ -[hidden]right-> RT

SCRREQ -[hidden]down-> EPOUT
RT     -[hidden]down-> SCRRES
EPOUT  -[hidden]right-> SCRRES

' =============================================================================
' Wiring: data flow
' =============================================================================
FCL -down..> INFER : PlanesTag,\nScratchDir,\nDefaultWrapper
MODELS -down..> INFER : per-model\nconfig
PATHS -down..> INFER : resolve\npaths

IMAGES -down-> INFER : planes (U/V/W)
INFER -down-> PRED : produces
INFER -down-> PERF : produces

RUN -down-> REQBIN : write request
REQBIN -right-> APPT : --in planes.bin

WRAP -down-> APPT : executed in\ncontainer
WTS -down-> APPT : --weights
ASSETS -down-> APPT : path resolve\n+ bind
CVMFS -down-> APPT : bind\n(optional)

APPT -down-> RESBIN : --out results.bin
APPT -down-> META : --metrics
APPT -down-> LOGS : redirect\nstdout/stderr

RESBIN -up-> RUN : read scores
META -up-> RUN : parse perf
LOGS -up..> RUN : on failure\nread stderr

note bottom of INFER
  Skip inference and write empty products if:
  - < 3 planes, or missing U/V/W
  - incompatible (WÃ—H) vs adc.size()
  - all planes empty (all ADC == 0)
end note

note right of RUN
  Executes (schematic):
  apptainer exec --cleanenv
    --bind <assets>,<scratch>[,/cvmfs]
    <container> /bin/bash <wrapper>
    --in planes.bin --out results.bin
    --metrics metrics.meta
    --W <width> --H <height>
    --arch <arch> --weights <weights>

  Then reads results.bin (IAOK/v1) + metrics.meta
  and cleans up scratch temp files.
end note

@enduml
